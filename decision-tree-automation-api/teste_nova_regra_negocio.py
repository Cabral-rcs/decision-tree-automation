#!/usr/bin/env python3
"""
Teste da nova regra de neg√≥cio: Categoriza√ß√£o baseada em previs√£o e status_operacao
"""

import sys
import os
from datetime import datetime, timedelta
import pytz

# Adiciona o diret√≥rio do backend ao path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from backend.models.responses_model import SessionLocal
from backend.models.alerta_model import Alerta

def test_nova_regra_negocio():
    """Teste da nova regra de neg√≥cio"""
    print("üß™ TESTE DA NOVA REGRA DE NEG√ìCIO")
    print("=" * 50)
    
    db = SessionLocal()
    try:
        # 1. Limpar alertas existentes
        print("1Ô∏è‚É£ Limpando alertas existentes...")
        db.query(Alerta).delete()
        db.commit()
        print("   ‚úÖ Alertas limpos")
        
        # 2. Criar alertas de teste
        print("\n2Ô∏è‚É£ Criando alertas de teste...")
        tz_br = pytz.timezone('America/Sao_Paulo')
        now_br = datetime.now(tz_br)
        
        # Alerta pendente (sem previs√£o)
        alerta_pendente = Alerta(
            chat_id='6435800936',
            problema='[TESTE] Alerta pendente',
            status='pendente',
            status_operacao='n√£o operando',
            nome_lider='Rafael Cabral',
            previsao=None,
            previsao_datetime=None,
            codigo='PEND001'
        )
        
        # Alerta escalada (previs√£o no futuro)
        previsao_futura = now_br + timedelta(hours=2)
        alerta_escalada = Alerta(
            chat_id='6435800936',
            problema='[TESTE] Alerta escalada',
            status='escalada',
            status_operacao='n√£o operando',
            nome_lider='Rafael Cabral',
            previsao='16:30',
            previsao_datetime=previsao_futura,
            respondido_em=now_br - timedelta(hours=1),
            codigo='ESC001'
        )
        
        # Alerta atrasada (previs√£o no passado)
        previsao_passada = now_br - timedelta(hours=2)
        alerta_atrasada = Alerta(
            chat_id='6435800936',
            problema='[TESTE] Alerta atrasada',
            status='atrasada',
            status_operacao='n√£o operando',
            nome_lider='Rafael Cabral',
            previsao='12:30',
            previsao_datetime=previsao_passada,
            respondido_em=now_br - timedelta(hours=3),
            codigo='ATR001'
        )
        
        # Alerta encerrada (status operando)
        alerta_encerrada = Alerta(
            chat_id='6435800936',
            problema='[TESTE] Alerta encerrada',
            status='encerrada',
            status_operacao='operando',
            nome_lider='Rafael Cabral',
            previsao='14:30',
            previsao_datetime=now_br - timedelta(hours=1),
            respondido_em=now_br - timedelta(hours=2),
            horario_operando=now_br - timedelta(minutes=30),
            origem_encerramento='escalada',
            codigo='ENC001'
        )
        
        # Adiciona todos os alertas
        db.add_all([alerta_pendente, alerta_escalada, alerta_atrasada, alerta_encerrada])
        db.commit()
        
        print(f"   ‚úÖ Alertas criados:")
        print(f"      - Pendente: ID {alerta_pendente.id}")
        print(f"      - Escalada: ID {alerta_escalada.id}")
        print(f"      - Atrasada: ID {alerta_atrasada.id}")
        print(f"      - Encerrada: ID {alerta_encerrada.id}")
        
        # 3. Testar categoriza√ß√£o
        print("\n3Ô∏è‚É£ Testando categoriza√ß√£o...")
        
        # Simula a l√≥gica de categoriza√ß√£o
        now = datetime.now(tz_br)
        pendentes = []
        escaladas = []
        atrasadas = []
        encerradas = []
        
        for alerta in db.query(Alerta).all():
            # NOVA REGRA DE NEG√ìCIO:
            # Pendentes: Alertas sem previs√£o
            # Escaladas: Alertas com previs√£o sem a previs√£o ter sido excedida
            # Atrasadas: Tempo excedido da previs√£o e status n√£o operando
            # Encerradas: Tempo excedido ou n√£o por√©m com status operando
            
            # 1. Pendentes: Alertas sem previs√£o
            if not alerta.previsao:
                pendentes.append(alerta)
                continue
            
            # 2. Encerradas: Status operando (independente da previs√£o)
            if alerta.status_operacao == 'operando':
                encerradas.append(alerta)
                continue
            
            # 3. Para alertas com previs√£o e status n√£o operando, verifica se a previs√£o foi excedida
            previsao_dt = alerta.previsao_datetime
            if previsao_dt:
                if previsao_dt.tzinfo is None:
                    previsao_dt = tz_br.localize(previsao_dt)
                else:
                    previsao_dt = previsao_dt.astimezone(tz_br)
                
                # 4. Escaladas: Com previs√£o, dentro da previs√£o e status n√£o operando
                if previsao_dt >= now:
                    escaladas.append(alerta)
                else:
                    # 5. Atrasadas: Previs√£o excedida e status n√£o operando
                    atrasadas.append(alerta)
            else:
                # Se tem previs√£o mas n√£o tem previsao_datetime, vai para escaladas
                escaladas.append(alerta)
        
        print(f"   üìä Resultado da categoriza√ß√£o:")
        print(f"      - Pendentes: {len(pendentes)} alertas")
        print(f"      - Escaladas: {len(escaladas)} alertas")
        print(f"      - Atrasadas: {len(atrasadas)} alertas")
        print(f"      - Encerradas: {len(encerradas)} alertas")
        
        # 4. Verificar se a categoriza√ß√£o est√° correta
        print("\n4Ô∏è‚É£ Verificando se a categoriza√ß√£o est√° correta...")
        
        # Verifica pendentes
        if len(pendentes) == 1 and pendentes[0].codigo == 'PEND001':
            print("   ‚úÖ Pendentes: CORRETO")
        else:
            print("   ‚ùå Pendentes: INCORRETO")
        
        # Verifica escaladas
        if len(escaladas) == 1 and escaladas[0].codigo == 'ESC001':
            print("   ‚úÖ Escaladas: CORRETO")
        else:
            print("   ‚ùå Escaladas: INCORRETO")
        
        # Verifica atrasadas
        if len(atrasadas) == 1 and atrasadas[0].codigo == 'ATR001':
            print("   ‚úÖ Atrasadas: CORRETO")
        else:
            print("   ‚ùå Atrasadas: INCORRETO")
        
        # Verifica encerradas
        if len(encerradas) == 1 and encerradas[0].codigo == 'ENC001':
            print("   ‚úÖ Encerradas: CORRETO")
        else:
            print("   ‚ùå Encerradas: INCORRETO")
        
        # 5. Testar mudan√ßa de status de atrasada para operando
        print("\n5Ô∏è‚É£ Testando mudan√ßa de status (atrasada ‚Üí operando)...")
        
        # Simula a mudan√ßa de status
        alerta_atrasada.status_operacao = 'operando'
        alerta_atrasada.horario_operando = now_br
        
        # Rastreia a origem do encerramento
        if alerta_atrasada.previsao:
            previsao_dt = alerta_atrasada.previsao_datetime
            if previsao_dt:
                if previsao_dt.tzinfo is None:
                    previsao_dt = tz_br.localize(previsao_dt)
                else:
                    previsao_dt = previsao_dt.astimezone(tz_br)
                
                if previsao_dt < now:
                    alerta_atrasada.origem_encerramento = 'atrasada'
                    print(f"   ‚úÖ Origem definida: atrasada")
                else:
                    alerta_atrasada.origem_encerramento = 'escalada'
                    print(f"   ‚úÖ Origem definida: escalada")
        
        db.commit()
        db.refresh(alerta_atrasada)
        
        print(f"   ‚úÖ Status atualizado:")
        print(f"      Status opera√ß√£o: {alerta_atrasada.status_operacao}")
        print(f"      Hor√°rio operando: {alerta_atrasada.horario_operando}")
        print(f"      Origem encerramento: {alerta_atrasada.origem_encerramento}")
        
        # 6. Testar categoriza√ß√£o ap√≥s mudan√ßa
        print("\n6Ô∏è‚É£ Testando categoriza√ß√£o ap√≥s mudan√ßa...")
        
        # Recategoriza
        pendentes = []
        escaladas = []
        atrasadas = []
        encerradas = []
        
        for alerta in db.query(Alerta).all():
            if not alerta.previsao:
                pendentes.append(alerta)
            elif alerta.status_operacao == 'operando':
                encerradas.append(alerta)
            else:
                previsao_dt = alerta.previsao_datetime
                if previsao_dt:
                    if previsao_dt.tzinfo is None:
                        previsao_dt = tz_br.localize(previsao_dt)
                    else:
                        previsao_dt = previsao_dt.astimezone(tz_br)
                    
                    if previsao_dt >= now:
                        escaladas.append(alerta)
                    else:
                        atrasadas.append(alerta)
                else:
                    escaladas.append(alerta)
        
        print(f"   üìä Resultado ap√≥s mudan√ßa:")
        print(f"      - Pendentes: {len(pendentes)} alertas")
        print(f"      - Escaladas: {len(escaladas)} alertas")
        print(f"      - Atrasadas: {len(atrasadas)} alertas")
        print(f"      - Encerradas: {len(encerradas)} alertas")
        
        # Verifica se o alerta foi movido para encerradas
        alerta_movido = None
        for alerta in encerradas:
            if alerta.codigo == 'ATR001':
                alerta_movido = alerta
                break
        
        if alerta_movido:
            print("   ‚úÖ Alerta atrasado foi movido para encerradas")
            if alerta_movido.origem_encerramento == 'atrasada':
                print("   ‚úÖ Origem corretamente definida como 'atrasada'")
                print("   ‚úÖ No frontend ser√° exibido com texto vermelho")
            else:
                print(f"   ‚ùå Origem incorreta: {alerta_movido.origem_encerramento}")
        else:
            print("   ‚ùå Alerta atrasado n√£o foi movido para encerradas")
        
        print("\n" + "=" * 50)
        print("üìã RESUMO DO TESTE DA NOVA REGRA DE NEG√ìCIO:")
        print("‚úÖ Categoriza√ß√£o baseada em previs√£o e status_operacao")
        print("‚úÖ Alertas pendentes (sem previs√£o)")
        print("‚úÖ Alertas escaladas (previs√£o n√£o excedida)")
        print("‚úÖ Alertas atrasadas (previs√£o excedida)")
        print("‚úÖ Alertas encerradas (status operando)")
        print("‚úÖ Mudan√ßa de status funciona corretamente")
        print("‚úÖ Origem do encerramento √© rastreada")
        print("üèÅ TESTE CONCLU√çDO")
        
    except Exception as e:
        print(f"‚ùå Erro no teste: {e}")
        import traceback
        print(f"Traceback: {traceback.format_exc()}")
    finally:
        db.close()

if __name__ == "__main__":
    test_nova_regra_negocio() 